# ACTION
### action creators สร้าง function และ return action ที่มี type กับ payload
- ใช้ async และ await ไม่ได้ เพราะว่าถูก transpli เป็น es5 แล้ว action ไม่ return action (js object plain) จึงเข้าใน dispatch ไม่ได้
- วิธีแก้คือใช้ middleware จัดการ โดยเป็น function ตัวนึงเช็คว่าได้ object plain รึยัง จากนั้นสั่ง dispatch แบบ manual
    - สนใจ return ถ้า return เป็น function ก็จะทำ loop เดิมจนกว่าจะได้ action จริงๆ
    - หลังจากได้ action ค่อยสั่ง dispatch
- middleware มีหลาย lib ให้ใช้ ในนี้ใช้ thunk

## const store = createStore(combineReducer({
  ชื่อ reducer : ชื่อแผนกใน redux store ใช้ชื่อเดียวกันก็ได้
}))

## วิธีเรียกดู state > store.getState();
## วิธี update state ใน redux store ต้องใช้ dispatch  > store.dispatch(action)

# REDUCERS
### เป็นแผนกที่ทำงาน โดนเอา  state (redux store) เข้ามา จากนั้นทำ action
/***
 * NOTE :
 * - REDUCERS คือแผนก มีหน้าที่ทำอะไรบางอย่างที่ dispatch ส่งข้อมูลมา (store.dispatch(..action..))
 * - reducers จะทำตาม state (ดึงมาจาก store), และ action type เพื่อ return object ไปเก็บที่ store
 * --- Rules of Reducers ---
 * - reducers ไม่ return undefined
 * - รับ state หรือ data ที่มาจาก previous state เท่านั้น (จาก redux store)
 *    - สำหรับตอนแรก init โปรแกรมไม่มี state (undefined) ให้ กำหนด default value ใน reducers เอาเอง
 *    - พอทำ state init จบ (reducer(state_init,action#1) > return state#1) ครั้งต่อไป reducers จะเรียก reducer(state#1, action#2)
 * - ไม่รับ หรือไม่ return อย่างอื่น นอกจาก state, action **
 * - ห้าม! mutate state ใน reducer จริงๆ JS ทำง่ายมาก พยายามอย่าใช้ method ที่ยุ่งกับ array, object เดิม ไปใช้พวก map, filter, forEach
 *    -- primitive เช่น number string จะเช็ค === ได้
 *    -- object เช่น array, object จะเช็ค === ได้เมื่ออยู่ reference เดียวกัน
 *      - const nums = [1] ,
 *      - nums === nums // true
 *      - nums === [1]; // false อยู่ memory คนละตำแหน่ง ถือว่าไม่เป็นอันเดียวกัน
 *  - จริงๆ แล้ว state ถูก mutate ทุกรอบของการ run reducer เพียงแต่ว่า function combineReducer มันมีตัวเช็คค่าของ state
 *  - hasChanged = hasChanged || nextStateForKey !== previousStateForKey >>>> 'true' run nextState, 'false' ให้หยุดที่ state ปัจจุบัน
 * - มันก็เลยเป็นที่มา ถ้าเรา mutate state เอง function ที่ว่ามันจะเพี้ยน ทำให้ส่ง state ต่อไปไม่ถูก !!!
 * ------ don't MUTATE state ------
 * - จัดการ array ใช้ rest [...oldArray, 'newMember']
 * - จัดการ object  ex const profile = {name : 'BAS'}
 *    - สร้าง object ใหม่ {... profile, name : 'Aib'} ไม่ได้ยุ่งกับของเดิม จะเอา
 *    - สร้าง property {... profile, age : 27}
 *    - overwrite ทุกครั้ง ถ้าใช้ key เหมือนกัน ด้านขวาจะ overwrite ซ้าย {name : 'Aib', ...profile} > out > {name : 'BAS'} เพราะ profile overwrite 'Aib'
 *    - delete object ใช้ loaddash lib (ช่วยจัดการ array,object) _.omit(profile, 'name') ลบ name ออก ได้ object ใหม่
 */


